<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive Bézier Rope</title>
    <style>
        canvas { border: 1px solid black; }
    </style>
</head>
<body>
    <canvas id="canvas" width="800" height="600"></canvas>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        // Bézier control points: P0 and P3 fixed, P1 and P2 dynamic
        let p0 = { x: 100, y: height / 2 };
        let p3 = { x: width - 100, y: height / 2 };
        let p1 = { x: width / 3, y: height / 2, vx: 0, vy: 0, targetX: width / 3, targetY: height / 2 };
        let p2 = { x: 2 * width / 3, y: height / 2, vx: 0, vy: 0, targetX: 2 * width / 3, targetY: height / 2 };

        // Physics constants
        const k = 0.1; // Spring stiffness
        const damping = 0.05; // Damping
        const maxVel = 500; // Velocity clamp

        // Mouse input
        let mouseX = width / 2;
        let mouseY = height / 2;
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });

        // Bézier curve function: B(t) = (1-t)^3 P0 + 3(1-t)^2 t P1 + 3(1-t) t^2 P2 + t^3 P3
        function bezierPoint(t, p0, p1, p2, p3) {
            const u = 1 - t;
            const uu = u * u;
            const tt = t * t;
            const uuu = uu * u;
            const ttt = tt * t;
            const p = uuu * p0.x + 3 * uu * t * p1.x + 3 * u * tt * p2.x + ttt * p3.x;
            const q = uuu * p0.y + 3 * uu * t * p1.y + 3 * u * tt * p2.y + ttt * p3.y;
            return { x: p, y: q };
        }

        // Derivative: B'(t) = 3(1-t)^2 (P1-P0) + 6(1-t)t (P2-P1) + 3t^2 (P3-P2)
        function bezierTangent(t, p0, p1, p2, p3) {
            const u = 1 - t;
            const uu = u * u;
            const tt = t * t;
            const dx = 3 * uu * (p1.x - p0.x) + 6 * u * t * (p2.x - p1.x) + 3 * tt * (p3.x - p2.x);
            const dy = 3 * uu * (p1.y - p0.y) + 6 * u * t * (p2.y - p1.y) + 3 * tt * (p3.y - p2.y);
            const len = Math.sqrt(dx * dx + dy * dy);
            return len > 0 ? { x: dx / len, y: dy / len } : { x: 0, y: 0 };
        }

        // Update physics for dynamic points
        function updatePhysics(dt) {
            // Set targets based on mouse (symmetric displacement for rope effect)
            const centerX = width / 2;
            const centerY = height / 2;
            const scale = 0.5; // Scale factor for displacement
            const dx = (mouseX - centerX) * scale;
            const dy = (mouseY - centerY) * scale;
            p1.targetX = p0.x + width / 3 + dx;
            p1.targetY = p0.y + dy;
            p2.targetX = p3.x - width / 3 - dx;
            p2.targetY = p3.y - dy;

            // Update P1
            const accX1 = -k * (p1.x - p1.targetX) - damping * p1.vx;
            const accY1 = -k * (p1.y - p1.targetY) - damping * p1.vy;
            p1.vx += accX1 * dt;
            p1.vy += accY1 * dt;
            p1.vx = Math.max(-maxVel, Math.min(maxVel, p1.vx));
            p1.vy = Math.max(-maxVel, Math.min(maxVel, p1.vy));
            p1.x += p1.vx * dt;
            p1.y += p1.vy * dt;

            // Update P2
            const accX2 = -k * (p2.x - p2.targetX) - damping * p2.vx;
            const accY2 = -k * (p2.y - p2.targetY) - damping * p2.vy;
            p2.vx += accX2 * dt;
            p2.vy += accY2 * dt;
            p2.vx = Math.max(-maxVel, Math.min(maxVel, p2.vx));
            p2.vy = Math.max(-maxVel, Math.min(maxVel, p2.vy));
            p2.x += p2.vx * dt;
            p2.y += p2.vy * dt;
        }

        // Render function
        function render() {
            ctx.clearRect(0, 0, width, height);

            // Draw Bézier curve
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            ctx.beginPath();
            let prev = bezierPoint(0, p0, p1, p2, p3);
            ctx.moveTo(prev.x, prev.y);
            for (let t = 0.01; t <= 1; t += 0.01) {
                const pt = bezierPoint(t, p0, p1, p2, p3);
                ctx.lineTo(pt.x, pt.y);
                prev = pt;
            }
            ctx.stroke();

            // Draw control points
            ctx.fillStyle = 'red';
            [p0, p1, p2, p3].forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 5, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Draw tangents at 5 points
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 1;
            const tangentLength = 20;
            [0.1, 0.3, 0.5, 0.7, 0.9].forEach(t => {
                const pt = bezierPoint(t, p0, p1, p2, p3);
                const tan = bezierTangent(t, p0, p1, p2, p3);
                ctx.beginPath();
                ctx.moveTo(pt.x, pt.y);
                ctx.lineTo(pt.x + tan.x * tangentLength, pt.y + tan.y * tangentLength);
                ctx.stroke();
            });
        }

        // Animation loop
        let lastTime = 0;
        function animate(time) {
            const dt = (time - lastTime) / 1000; // seconds
            lastTime = time;
            if (dt > 0.1) return; // Skip large dt to prevent instability

            updatePhysics(dt);
            render();
            requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
    </script>
</body>
</html>